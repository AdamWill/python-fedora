# -*- coding: utf-8 -*-
#
# Copyright Â© 2008  Red Hat, Inc. All rights reserved.
#
# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.  This program is distributed in the hope that it
# will be useful, but WITHOUT ANY WARRANTY expressed or implied, including the
# implied warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.  You should have
# received a copy of the GNU General Public License along with this program;
# if not, write to the Free Software Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301, USA. Any Red Hat trademarks that are
# incorporated in the source code or documentation are not subject to the GNU
# General Public License and may only be used or replicated with the express
# permission of Red Hat, Inc.
#
# Author(s): Toshio Kuratomi <tkuratom@redhat.com>
# Author(s): Mike Watters <valholla@fedoraproject.org>
#
'''Module to provide a library interface to the package database.

.. moduleauthor:: Toshio Kuratomi <tkuratom@redhat.com>
.. moduleauthor:: Mike Watters <valholla@fedoraproject.org>

.. data:: COLLECTIONMAP
    Maps short names to Collections.  For instance, FC => Fedora
'''

import simplejson

from fedora import __version__, _
from fedora.client import BaseClient, FedoraClientError, AppError

COLLECTIONMAP = {'F': 'Fedora',
    'FC': 'Fedora',
    'EL': 'Fedora EPEL',
    'EPEL': 'Fedora EPEL',
    'OLPC': 'Fedora OLPC',
    'RHL': 'Red Hat Linux'}

class PackageDBError(FedoraClientError):
    '''Errors generated by the PackageDB Client.'''
    pass

### FIXME: Port Exceptions on the server
# The PackageDB server returns errors errors as a dict with:
#   {'status': False, 'message': 'error message'}
# The new way of doing this is to set
#   {'exc': 'Exception name', tg_flash: 'error message'}
# So this needs to be ported on the server and we need to change error
# checking code to something like this:
# request = self.send_request([...])
# if 'exc' in request:
#   raise AppError(name=request['exc'], message=request['tg_flash'])
#
# Everywhere that currently sets AppError(name='PackageDBError',[...]) will
# need to be changed.

class PackageDB(BaseClient):
    '''Provide an easy to use interface to the PackageDB.'''
    def __init__(self, base_url='https://admin.fedoraproject.org/pkgdb/',
            *args, **kwargs):
        '''Create the PackageDB client.

        :kwarg base_url: Base of every URL used to contact the server.
            Defaults to the Fedora PackageDB instance.
        :kwarg useragent: useragent string to use.  If not given, default to
            "Fedora PackageDB Client/VERSION"
        :kwarg debug: If True, log debug information
        :type debug: bool
        :kwarg username: username for establishing authenticated connections
        :kwarg password: password to use with authenticated connections
        :kwarg session_id: user's session_id to connect to the server
        :type session_id: string
        :kwarg session_cookie: **Deprecated** use session_id instead.
            user's session_cookie to connect to the server
        :kwarg cache_session: if set to True, cache the user's session cookie
            on the filesystem between runs.
        :type kwarg: bool
        '''
        if 'useragent' not in kwargs:
            kwargs['useragent'] = 'Fedora PackageDB Client/%s' % __version__
        super(PackageDB, self).__init__(base_url, *args, **kwargs)

    def get_package_info(self, pkg_name, branch=None):
        '''Get information about the package.

        :arg pkg_name: Name of the package
        :kwarg branch: If given, restrict information returned to this branch
            Allowed branches are listed in :data:`COLLECTIONMAP`
        :raises AppError: If the server returns an exceptiom
        :returns: Package ownership information
        :rtype: fedora.client.DictContainer
        '''
        data = None
        if branch:
            collection, ver = self.canonical_branch_name(branch)
            data = {'collectionName': collection, 'collectionVersion': ver}
        pkg_info = self.send_request('/packages/name/%s' % pkg_name,
                req_params=data)

        if 'status' in pkg_info and not pkg_info['status']:
            raise AppError(name='PackageDBError', message=pkg_info['message'])
        return pkg_info

    def clone_branch(self, pkg, master, branches, owner=None, description=None,
            branches=None, cc_list=None, comaintainers=None, groups=None):
        '''Set a branch's permissions from a pre-existing branch.

        :arg pkg: Name of the package to branch
        :arg master: Short branch name to clone from.  Allowed branch names
            are listed in :data:`COLLECTIONMAP`
        :arg branches: List or tuple of branches to clone to.  Allowed branch
            names are listed in :data:`COLLECTIONMAP`
        :kwarg owner: If set, make this person the owner of both branches
        :kwarg description: If set, make this the description of both branches
        :kwarg cc_list: If set, list or tuple of usernames to watch the
            package.
        :kwarg comaintainers: If set, list or tuple of usernames to comaintain
            the package.
        :kwarg groups: If set, list or tuple of group names that can commit to
            the package.
        :raises AppError: If the server returns an exceptiom

        Note: This method is going to be changing in the near future.  We
        want to split the functionality up so this method is strictly about
        cloning one branch to another.  The optional elements that change
        attributes of the master branch prior to cloning should be done as a
        separate call to :meth:`add_edit_branch` first.
        '''

        if groups or comaintainers or cc_list or description or owner:
            # Set the updated information on the master branch first
            self.add_edit_package(pkg, owner, description, [master], cc_list,
                    comaintainers, groups)

        # Get information on the master branch
        try:
            pkg_info = self.get_package_info(pkg, master)
        except AppError, e:
            for i, arg in enumerate(e.args):
                if arg == e.message:
                    e.message = _('%(pkg)s has no %(branch)s branch; cannot'
                        ' clone from it.  Error: %(msg)s') % {'pkg': pkg,
                            'branch': master, 'msg': arg}
                    e.args[i] = arg
                    break
            raise
        status_map = pkg_info['statusMap']
        pkg_info = pkg_info['packageListings'][0]

        # Make sure the master branch is not in the list of branches to change
        try:
            del branches[branches.index(master)]
        except ValueError: # pylint: disable-msg=W0704
            # Exception means it wasn't there to begin with (W0704)
            pass

        # Change group_list into the format the server is expecting
        group_list = {}
        for group in pkg_info['groups']:
            if group['aclOrder']['commit'] and status_map[str(
                    group['aclOrder']['commit']['statuscode'])] == 'Approved':
                group_list[group['name']] = True
            else:
                group_list[group['name']] = False

        # Set all the branches to have the new branch information
        self.add_edit_package(pkg,
                pkg_info['owneruser'],
                None, branches, None, None, group_list)

        # All acls that we want to end up on the new branch
        acl_changes = {}
        for branch in branches:
            acl_changes[branch] = {}
            for person in pkg_info['people']:
                person_acls = {}
                acl_changes[branch][person['userid']] = person_acls
                for acl in person['aclOrder']:
                    if person['aclOrder'][acl]:
                        person_acls[acl] = status_map[str(
                            person['aclOrder'][acl]['statuscode'])]

        #
        # Scan through each branch to remove acls that are set but need to be
        # removed and to not set acls that already correct in the pkgdb
        #

        # Get updated package info
        branch_ids = {} # PackageListingIds
        all_pkg_info = self.get_package_info(pkg)
        for pkg_listing in all_pkg_info['packageListings']:
            if pkg_listing['collection']['branchname'] in branches:
                # Branch we're interested in
                branch = pkg_listing['collection']['branchname']
                branch_ids[branch] = pkg_listing['id']
                for person in pkg_listing['people']:
                    try:
                        person_acls = acl_changes[branch][person['userid']]
                    except KeyError:
                        # person should not have an acl in the cloned entry
                        person_acls = {}
                        acl_changes[branch][person['userid']] = person_acls
                        # If a person's acls weren't Obsolete before, make
                        # them so now.
                        for acl in person['aclOrder']:
                            if person['aclOrder'][acl] and status_map[str(
                                person['aclOrder'][acl]['statuscode'])] != \
                                        'Obsolete':
                                person_acls[acl] = 'Obsolete'
                    else:
                        for acl in person['aclOrder']:
                            if not person['aclOrder'][acl]:
                                # Was unspecified before and...
                                if acl not in person_acls or \
                                        not person_acls[acl] or \
                                        person_acls[acl] ==  'Obsolete':
                                    # Unspecified or obsolete now, no need to
                                    # set it to Obsolete
                                    try:
                                        del person_acls[acl]
                                    except KeyError: # pylint: disable-msg=W0704
                                        # Already unset, no need to do
                                        # anything (W0704)
                                        pass
                                # Otherwise we need to set it
                            elif acl not in person_acls:
                                # Was not obsolete before, need to Obsolete
                                # this acl now
                                person_acls[acl] = 'Obsolete'
                            else:
                                # If the status is already correct, no need to
                                # set it again
                                statuscode = str(
                                        person['aclOrder'][acl]['statuscode'])
                                if statuscode in status_map and \
                                        status_map[statuscode] == \
                                        person_acls[acl]:
                                    del person_acls[acl]
                                # Otherwise we need to set it

        del all_pkg_info

        # Actually set acl information now
        # acl information needs to be set separately as the compat interface
        # add_edit_package is using can't handle the complexity
        for branch in acl_changes:
            for person in acl_changes[branch]:
                for acl in acl_changes[branch][person]:
                    data = {'pkgid': branch_ids[branch],
                            'personid': person,
                            'new_acl': acl,
                            'statusname': acl_changes[branch][person][acl]}
                    response = self.send_request(
                            '/packages/dispatcher/set_acl_status',
                            auth=True, req_params=data)
                    if 'status' in response and not response['status']:
                        raise AppError(name='PackageDBError',
                                messsage =_('PackageDB returned an error'
                                ' while setting acls for %(person)s on'
                                ' %(pkg)s: %(msg)s') % \
                                        {'person': data['personid'],
                                            'pkg': data['pkgid'],
                                            'msg': response['message']})

    def add_edit_package(self, pkg, owner=None, description=None,
            branches=None, cc_list=None, comaintainers=None, groups=None):
        '''Add or edit a package to the database.

        :arg pkg: Name of the package to edit
        :kwarg owner: If set, make this person the owner of both branches
        :kwarg description: If set, make this the description of both branches
        :kwarg cc_list: If set, list or tuple of usernames to watch the
            package.
        :kwarg comaintainers: If set, list or tuple of usernames to comaintain
            the package.
        :kwarg groups: If set, list or tuple of group names that can commit to
            the package.
        :raises AppError: If the server returns an error

        This method takes information about a package and either edits the
        package to reflect the changes to information or adds the package to
        the database.

        Note: This method will be going away in favor of methods that do
        smaller chunks of work:
            1) A method to add a new package
            2) A method to add a new branch
            3) A method to edit an existing package
            4) A method to edit and existing branch
        '''
        # Check if the package exists
        try:
            self.get_package_info(pkg)
        except AppError:
            # Package doesn't exist yet.  See if we have the information to
            # create it
            if owner:
                if 'devel' not in branches:
                    # automatically add a devel branch to new packages
                    branches.append('devel')

                data = {'package': pkg, 'owner': owner, 'summary': description}
                # This call creates the package and an initial branch for
                # Fedora devel
                response = self.send_request('/packages/dispatcher/add_package',
                    auth=True, req_params=data)
                if 'status' in response and not response['status']:
                    raise AppError(name='PackageDBError', message=
                        _('PackageDB returned an error creating %(pkg)s:'
                        ' %(msg)s') % {'pkg': pkg, 'msg': response['message']})
                owner = None
                description = None
            else:
                raise PackageDBError, _('Package %(pkg)s does not exist and we'
                        ' do not have enough information to create it.') % \
                                {'pkg': pkg}

        # Change the branches, owners, or anything else that needs changing
        data = {}
        if owner:
            data['owner'] = owner
        if description:
            data['summary'] = description
        if cc_list:
            data['ccList'] = simplejson.dumps(cc_list)
        if comaintainers:
            data['comaintList'] = simplejson.dumps(comaintainers)

        # Parse the groups information
        if groups:
            data['groups'] = simplejson.dumps(groups)

        # Parse the Branch abbreviations into collections
        if branches:
            data['collections'] = {}
        for branch in branches:
            collection, version = self.canonical_branch_name(branch)
            # Create branch
            try:
                data['collections'][collection].append(version)
            except KeyError:
                data['collections'][collection] = [version]

        # Transform the collections dict into JSON.
        data['collections'] = simplejson.dumps(data['collections'])

        # Request the changes
        response = self.send_request('/packages/dispatcher/edit_package/%s'
                % pkg, auth=True, req_params=data)
        if 'status' in response and not response['status']:
            raise AppError(name='PackageDBError', message=_('Unable to save'
                ' all information for %(pkg)s: %(msg)s') % {'pkg': pkg,
                    'msg': response['message']})

    def canonical_branch_name(self, branch):
        '''Change a branch abbreviation into a name and version.

        :arg branch: branch abbreviation
        :rtype: tuple
        :returns: tuple of branch name and branch version.

        Example:
        >>> name, version = canonical_branch_name('FC-6')
        >>> name
        Fedora
        >>> version
        6
        '''
        if branch == 'devel':
            collection = 'Fedora'
            version = 'devel'
        else:
            collection, version = branch.split('-')
        try:
            collection = COLLECTIONMAP[collection]
        except KeyError:
            raise PackageDBError, _('Collection abbreviation %(collection)s is'
                    ' unknown.  Use F, FC, EL, or OLPC') % \
                            {'collection': collection}

        return collection, version


    def get_owners(self, package, collection=None, collection_ver=None):
        '''Retrieve the ownership information for a package.

        :arg package: Name of the package to retrieve package information about.
        :kwarg collection: Limit the returned information to this collection
            ('Fedora', 'Fedora EPEL', Fedora OLPC', etc)
        :kwarg collection_ver: If collection is specified, further limit to this
            version of the collection.
        :raises AppError: If the server returns an error
        :rtype: DictContainer
        :return: dict of ownership information for the package
        '''
        method = '/packages/name/%s' % package
        if collection:
            method = method + '/' + collection
            if collection_ver:
                method = method + '/' + collection_ver

        response = self.send_request(method)
        if 'status' in response and not response['status']:
            raise AppError(name='PackageDBError', message=response['message'])
        ###FIXME: Really should reformat the data so we show either a
        # dict keyed by collection + version or
        # list of collection, version, owner
        return response
